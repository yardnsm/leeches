package parcel

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

type SampleType struct {
	Name    string
	Age     int
	Friends []SampleType
}

var sampleValue SampleType = SampleType{
	Name: "John",
	Age:  18,
	Friends: []SampleType{
		{"Jane", 22, nil},
		{"Bil", 25, nil},
		{"Jack", 19, nil},
	},
}

func TestMarshal(t *testing.T) {
	marshalled1, err1 := Marshal(sampleValue, testCipherKey)
	marshalled2, err2 := Marshal(sampleValue, testCipherKey)

	assert.NoError(t, err1)
	assert.NoError(t, err2)

	t.Run("two marshals should not be the same", func(t *testing.T) {
		assert.NotEqual(t, marshalled1, marshalled2)
	})
}

func TestUnmarshal(t *testing.T) {
	marshalled :=
		[]byte{0x61, 0x66, 0x38, 0x64, 0x33, 0x65, 0x61, 0x66, 0x35, 0x31, 0x65, 0x37, 0x65, 0x63, 0x64, 0x34, 0x64, 0x31, 0x32, 0x35, 0x65, 0x39, 0x66, 0x65, 0x7c, 0x33, 0x36, 0x64, 0x65, 0x61, 0x34, 0x36, 0x61, 0x31, 0x32, 0x35, 0x36, 0x39, 0x34, 0x35, 0x31, 0x34, 0x32, 0x32, 0x35, 0x31, 0x34, 0x61, 0x39, 0x63, 0x31, 0x34, 0x34, 0x31, 0x39, 0x35, 0x65, 0x34, 0x62, 0x39, 0x62, 0x39, 0x61, 0x37, 0x66, 0x36, 0x36, 0x34, 0x64, 0x66, 0x34, 0x62, 0x65, 0x66, 0x65, 0x63, 0x39, 0x63, 0x35, 0x34, 0x34, 0x62, 0x35, 0x33, 0x34, 0x31, 0x61, 0x62, 0x33, 0x7c, 0x39, 0x32, 0x38, 0x65, 0x30, 0x30, 0x30, 0x63, 0x36, 0x38, 0x33, 0x61, 0x35, 0x61, 0x37, 0x63, 0x30, 0x32, 0x39, 0x32, 0x34, 0x35, 0x39, 0x36, 0x34, 0x38, 0x61, 0x62, 0x64, 0x61, 0x36, 0x32, 0x62, 0x61, 0x35, 0x38, 0x34, 0x62, 0x31, 0x38, 0x64, 0x37, 0x38, 0x33, 0x66, 0x30, 0x35, 0x64, 0x62, 0x66, 0x64, 0x38, 0x62, 0x66, 0x65, 0x39, 0x38, 0x35, 0x65, 0x31, 0x36, 0x65, 0x65, 0x32, 0x61, 0x38, 0x65, 0x37, 0x34,  0x66, 0x61, 0x33, 0x35, 0x36, 0x66, 0x35, 0x61, 0x31, 0x35, 0x31, 0x66, 0x34, 0x34, 0x66, 0x31, 0x32, 0x36, 0x31, 0x34, 0x62, 0x64, 0x31, 0x61, 0x35, 0x65, 0x30, 0x31, 0x35, 0x33, 0x30, 0x38, 0x30, 0x32, 0x32, 0x36, 0x33, 0x30, 0x35, 0x34, 0x65, 0x39, 0x33, 0x39, 0x36, 0x35, 0x38, 0x37, 0x33, 0x37, 0x33, 0x62, 0x39, 0x62, 0x35, 0x63, 0x33, 0x37, 0x35, 0x37, 0x33, 0x38, 0x32, 0x31, 0x31, 0x66, 0x32, 0x30, 0x37, 0x39, 0x35, 0x38, 0x34, 0x33, 0x36, 0x32, 0x38, 0x65, 0x66, 0x39, 0x32, 0x65, 0x61, 0x35, 0x34, 0x39, 0x30, 0x32, 0x34, 0x36, 0x66, 0x64, 0x32, 0x61, 0x34, 0x65, 0x39, 0x61, 0x61, 0x39, 0x32, 0x61, 0x31, 0x62, 0x34, 0x31, 0x34, 0x32, 0x36, 0x30, 0x65, 0x62, 0x38, 0x61, 0x37, 0x31, 0x30, 0x33, 0x63, 0x35, 0x34, 0x33, 0x36, 0x63, 0x63, 0x33, 0x66, 0x62, 0x32, 0x34, 0x39, 0x61, 0x33, 0x63, 0x30, 0x61, 0x64, 0x30, 0x32, 0x31, 0x65, 0x37, 0x65, 0x35, 0x32, 0x34, 0x32, 0x38, 0x62, 0x62, 0x30, 0x30, 0x61, 0x34, 0x62, 0x66, 0x32, 0x31, 0x37, 0x65, 0x30, 0x63, 0x32, 0x32, 0x33, 0x31, 0x31, 0x38, 0x34, 0x65, 0x37, 0x39, 0x37, 0x30, 0x63, 0x31, 0x33, 0x32, 0x30, 0x31, 0x32, 0x64, 0x65, 0x37, 0x64, 0x65, 0x63, 0x39, 0x36, 0x37, 0x39, 0x61, 0x33, 0x35, 0x35, 0x65, 0x63, 0x61, 0x64, 0x65, 0x63, 0x32, 0x33, 0x34, 0x62, 0x64, 0x33, 0x32, 0x30, 0x39, 0x63, 0x30, 0x63, 0x38, 0x35, 0x38, 0x33, 0x36, 0x35, 0x34, 0x36, 0x30, 0x36, 0x64, 0x61, 0x36, 0x38, 0x62, 0x39, 0x66, 0x32, 0x37, 0x36, 0x66, 0x61, 0x32, 0x30, 0x34, 0x66, 0x64, 0x33, 0x65, 0x38, 0x30, 0x35, 0x32, 0x38, 0x35, 0x37, 0x39, 0x33, 0x34, 0x37, 0x36, 0x31, 0x64, 0x33, 0x65, 0x63, 0x61, 0x31, 0x30, 0x31, 0x63, 0x61, 0x61, 0x64, 0x33, 0x66, 0x31, 0x35, 0x32, 0x38}

	var unmarshalled SampleType
	err := Unmarshal(marshalled, testCipherKey, &unmarshalled)

	assert.NoError(t, err)
	assert.Equal(t, unmarshalled, sampleValue)
}
